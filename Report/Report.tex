\documentclass{article}

\usepackage{multirow}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cancel}
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}
\newtheorem{claim}{Claim}




% allows for temporary adjustment of side margins
\usepackage{chngpage}

% just makes the table prettier (see \toprule, \bottomrule, etc. commands below)
\usepackage{booktabs}


\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\begin{document}

\title{Project 1: A Python Interpreter for the Browser}
\author{Ian Gemp and Shaylyn Adams}
\maketitle

\section{Introduction}
The goal of this project is to write a typescript program that will interpret python bytecode (.pyc) in the browser.  Our general approach split this task into three parts: parsing the bytecode, interpreting the result, and porting to the browser.  All preliminary work was to be done outside the browser using node.js with the last step being the transition to the browser using browserFS.\\
\\
When python (.py) files are executed, they are compiled into bytecode (.pyc) and interpreted by the python interpreter (e.g. CPython, PyPy, etc.).  The bytecode itself is conveniently universal across the interpreters of the same version (e.g. Python 2.7).  In all subsequent executions of the python file (.py), the interpreter will run the bytecode (.pyc) directly in order to save time re-compiling the python file (.py) assuming the python file (.py) has not changed since its last compilation.  In reality, the bytecode (.pyc) must be read and parsed in its entirety before the python implementation actually executes the source.

\section{Parsing}

The python bytecode (.pyc) adheres to a strict format, the ``Marshall'' format, that can be read and interpreted by the python implementation (e.g. CPython).  The majority of the bytecode is structured in a way such that the interpreter can read in the bytecode stream as an alternating sequence of datum (singular piece of data) and datum types.  Some of the datum types represent containers (e.g. objects, namespaces, etc.) and a natural hierarchy of data results.

\subsection{Parsing Dependencies}

- Our program assumes the python bytecode was compiled with Python 2.7 although we believe the marshal format is consistent across the 2.x line.\\
- The long data type is not implemented, however, integers, floats, and complex (32 and 64 bit) are handled.

\subsection{Understanding Python Bytecode}

As mentioned above, the majority of the python bytecode is structured as an alternating series of types and data chunks, however the first 8 bytes (64 bits) of bytecode are specially formatted.  The first 4 bytes (32 bits) of bytecode represent a magic number corresponding to the marshal format version.  The second 4 bytes are the modification timestamp of the python source file (.py).  The next byte constitutes the beginning of the type/datum sequence.  Each ``type-byte'' is stored in the bytecode as an unsigned 8 bit integer representing a single character.  This character corresponds to a specific datum type, which dictates how the following bytes should be read in order to correctly parse the corresponding datum.  For instance, the type-byte ``s'' indicates that the datum is a string.  The 4 bytes (32 bits) following the type-byte are a signed integer representing the size of the string to be read.  Once the string is parsed, the program moves to the following byte and expects to encounter another type-byte.  The only way this rule is broken is if the program has moved beyond the length of the bytecode file, in which case parsing is complete.  The diagram below depicts this example and the general algorithmic scheme for parsing the bytecode.\\
\\
\begin{minipage}{\textwidth}
\begin{minipage}{0.35\textwidth}
\begin{verbatim}
1) Read Magic Number
2) Read Timestamp
3) While Not End of File
4)     Parse (Type,Datum)
\end{verbatim}
\end{minipage}
\begin{minipage}{.64\textwidth}
\begin{tabular}{ c | c | c | c | c | c | c | c | c }
type & size (int32LE) & \multicolumn{5}{|c|}{string} & type & $\ldots$ \\ \hline
's' & 5 & h & e & l & l & o & 'c' & \ldots \\ \hline
\end{tabular}
\end{minipage}
\end{minipage}
\\\\
The resulting parsed bytecode consists of a series of {\em code objects} containing {\em opcodes}, stored constants, argument names, and other general information.  Code objects may appear nested within a list of constants creating a nested hierarchy of code objects.

\subsection{Our Implementation}

Numeric data types (integer, float, complex) read in by the parser are immediately converted to the appropriate class objects in javascript.  The typical builtin arithmetic functions are maintained as methods of the numeric objects.  When arithmetic operations are called by the interpreter (e.g. +), a generic javascript builtin (e.g. add) is called which implements the data type's method.  If that operation is not implemented by that data type, the inverse method is called by the operand.  For instance, \verb!<int>.__add__(<float>)! returns `NotImplemented' and so its inverse, \verb!<float>.__add__(<int>)!, which is in fact implemented.  If both calls fail, then an error is thrown.\\
\\
The largest parsing function is devoted to parsing the code object which contains a number of properties most important of which are the opcode list, consts, names, varnames, freezers, and cellars.  The first contains the list of instructions to be executed by the interpreter.  Consts contains constants as its name implies while the rest contain variables to be replaced and loaded by function calls.\\
\\
An important object not given sufficient attention in python documentation is the interned list.  The interned list is a global variable containing a list of names referred to by any number of code objects during bytecode execution.  The parser must add certain strings to this list in order for the execution to function properly.

\section{Interpreter}

Once the bytecode has been fully parsed, the python interpreter begins to proceed through the op codes, or instruction list, of the highest level code object (representing the source module).  The interpreter maintains its place in the instruction list with a program counter pointing to the byte offset in the instruction list of the current instruction.  Opcode execution consists of a series of stack manipulations and completes by updating the program to point to the next instruction.  The interpreter is finished when the program counter has moved beyond the end of the instruction list of the highest level code object.

\subsection{Interpreter Dependencies}

- Iterator objects are not implemented (i.e. for loops), however, while loops function as expected.\\
- With blocks are not implemented.\\
- Imports are not implemented although our interface only allows a single .pyc file to be run at once, so it's not to be expected.\\
- Sets and maps are not implemented.\\
- A few other opcodes are not implemented as well, but we have yet to use some of these in our own extensive work with python so do not expect them to be major obstacles.

\subsection{Understanding the Interpreter}

The interpreter functions in a manner that is very similar to the parser.  The interpreter's role is to proceed through the list of opcode instructions which consists of alternating sequences of operators and operands.  The operands only exist for certain operators and provide information such as the number of arguments to pop of the stack, where to find certain elements in the code objects variable lists, etc.  The diagram below depicts an example along with the general algorithmic scheme for the interpreter.%\\
%\\
%\begin{minipage}{\textwidth}
%\begin{minipage}{0.35\textwidth}
\begin{verbatim}
1) While Not End of Instruction Set
2)     Read Op Code Operator
3)     Read Op Code Operand (if any)
4)     Execute Operation (most likely manipulates stack)
\end{verbatim}
%\end{minipage}
%\begin{minipage}{.64\textwidth}
\begin{tabular}{ c | c | c | c | c }
operator & operand (int16) & operator & operand (int8,int8) & $\ldots$ \\ \hline
100 (\verb!LOAD_CONST!) & 0 (index in consts) & 131 (\verb!CALL_FUNCTION!) & (\# args,\# kwargs) & \ldots \\ \hline
\end{tabular}
%\end{minipage}
%\end{minipage}
%\\\\

\subsection{Our Implementation}
In our implementation, each opcode has a corresponding function which executes a series of operations by manipulating the stack object.  Upon completion of the opcode execution, the program counter is updated to point to the next instruction to be executed.\\
\\
We chose to treat the stack as a global object as opposed to maintaining a separate stack for each frame (i.e. code object).  This made implementing the interpreter easier, however, it prohibits us from incorporating threading since a global stack requires operations to occur sequentially whereas threads can manipulate the stack asynchronously as long as they obey data dependencies.\\
\\
The heaviest opcode by far is the call function opcode.  This op code carries out a series of operations including retrieving arguments off the stack, passing arguments to the function to be called, executing the corresponding function's op code list, and finally pushing the returned value to the stack.  It's interesting to note that python makes function calls to class objects directly instead of first retrieving the object's constructor ('\_\_init\_\_') as an attribute which is how it handles all other class method calls.  For this reason, we check to see if the function being called is actually a function object or if it is in fact a class object.  We also check to see if the function refers to a builtin such as float() which we have implemented directly in javascript.  Once the function has been identified, its argument names list is retrieved for comparison against the arguments supplied on the stack.  Keyword arguments, positional arguments, and default values are added to an argument list that will be used by the function.  The function is then called, either by executing its list of opcodes or by calling the builtin directly.  The returned value is then pushed to the stack.\\
\\
Since the mechanisms behind try-except, loops, and blocks in general are not well documented, we designed our own implementation to handle exceptions.  In our interpreter, the block stack is global and individual blocks hold properties defining their type (e.g. 'except') as well as a boolean flag indicating the state of the program.  The program may raise an exception by constructing an error object and calling it's throw method.  When an exception is thrown, the top of the block stack is temporarily popped and it's flag is set to true if the block is an exception block (e.g. type equals 'except').  If the block is not an exception block, the program is halted.  Otherwise, the program continues and is expected to encounter a pop block statement which pops a block, inspects it's flag, and updates the program counter to the start of the exception handler if the flag is true.

\section{Browser Interface}

The browser interface is very simple.  The user may choose a single .pyc file to interpret.  The user then has the option of viewing the interpreter operations in detail including opcode execution and stack manipulation or viewing only the output that is printed out by the program.  {\em Run Interpreter} clears any bytecode in local storage and then interprets the bytecode while {\em Clear Output} clears the text area.\\
\\
The interpreter is located at \verb!http://shaylyna.github.io/630Systems_Project1/!.  In order to run the test suite, simply choose the file \verb!testSuite.pyc!.  This file tests a number of operations outlined below:\\
\\
- Storing constants\\
- If else statements\\
- Printing\\
- Function creation \& function calls\\
- Argument handling (args, kwargs, defaults)\\
- Document strings and other function properties\\
- Classes and property arguments\\
- Dictionaries and tuples\\
- While loops plus break and continue statements\\
- Builtins (not all of them)\\
- Try catch blocks\\
- Integer, Float, and Complex arithmetic\\

\section{Conclusion}

Our initial impression of python bytecode and the underlying mechanisms of the interpreter was complete bewilderment.  Documentation is sparse at best and very few references are available online.  Only a few rare enthusiasts have explored the machinery.  As we put together the bare skeleton of the interpreter and became more comfortable with its high level operations, we began to see the elegance of the design.  This impression lasted only temporarily.  Once we began to implement more complex features (e.g. classes, blocks, etc.), we discovered that the supposedly elegant design is really just a simplistic container for more the obscure, subtle operations happening inside the interpreter.  It appears as though the creators did their best to adhere to a simple design philosophy as long as they could until they were forced to abandon the approach for a more practical engineering effort.  Some of their final design choices still elude us.\\
\\
 Although our learning curve was extremely shallow at first, we eventually ramped up to speed and started to understand the inner workings of the python bytecode and interpreter.  The principles learned from this project are extremely valuable and we have already begun to apply some of them in our work outside of class.


















\end{document}